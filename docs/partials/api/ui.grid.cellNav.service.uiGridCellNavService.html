<h1><code ng:non-bindable="">uiGridCellNavService</code>
<span class="hint">(service in module <code ng:non-bindable="">ui.grid.cellNav</code>
)</span>
</h1>
<div><h2 id="Description">Description</h2>
<div class="description"><p>Services for cell navigation features. If you don't like the key maps we use,
or the direction cells navigation, override with a service decorator (see angular docs)</p></div>
<div class="member method"><h2 id="Methods">Methods</h2>
<ul class="methods"><li><h3 id="cellNavColumnBuilder">cellNavColumnBuilder()</h3>
<div class="cellnavcolumnbuilder"><p>columnBuilder function that adds cell navigation properties to grid column</p><h4 id="Returns">Returns</h4>
<div class="returns"><code ng:non-bindable="">{promise}</code>
– <p>promise that will load any needed templates when resolved</p></div>
</div>
</li>
<li><h3 id="decorateRenderContainers">decorateRenderContainers()</h3>
<div class="decoraterendercontainers"><p>decorates grid renderContainers with cellNav functions</p></div>
</li>
<li><h3 id="getDirection">getDirection()</h3>
<div class="getdirection"><p>determines which direction to for a given keyDown event</p><h4 id="Returns">Returns</h4>
<div class="returns"><code ng:non-bindable="">{uiGridCellNavConstants.direction}</code>
– <p>direction</p></div>
</div>
</li>
<li><h3 id="getLeftWidth">getLeftWidth(grid, upToCol)</h3>
<div class="getleftwidth"><p>Get the current drawn width of the columns in the
grid up to the numbered column, and add an apportionment for the
column that we're on.  So if we are on column 0, we want to scroll
0% (i.e. exclude this column from calc).  If we're on the last column
we want to scroll to 100% (i.e. include this column in the calc). So
we include (thisColIndex / totalNumberCols) % of this column width</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">grid – {Grid} – </code>
<p>the grid you'd like to act upon, usually available
from gridApi.grid</p></li>
<li><code ng:non-bindable="">upToCol – {gridCol} – </code>
<p>the column to total up to and including</p></li>
</ul>
</div>
</li>
<li><h3 id="scrollTo">scrollTo(grid, $scope, rowEntity, colDef)</h3>
<div class="scrollto"><p>Scroll the grid such that the specified
row and column is in view</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">grid – {Grid} – </code>
<p>the grid you'd like to act upon, usually available
from gridApi.grid</p></li>
<li><code ng:non-bindable="">$scope – {object} – </code>
<p>a scope we can broadcast events from</p></li>
<li><code ng:non-bindable="">rowEntity – {object} – </code>
<p>gridOptions.data[] array instance to make visible</p></li>
<li><code ng:non-bindable="">colDef – {object} – </code>
<p>to make visible</p></li>
</ul>
</div>
</li>
<li><h3 id="scrollToFocus">scrollToFocus(grid, $scope, rowEntity, colDef)</h3>
<div class="scrolltofocus"><p>Scroll the grid such that the specified
row and column is in view, and set focus to the cell in that row and column</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">grid – {Grid} – </code>
<p>the grid you'd like to act upon, usually available
from gridApi.grid</p></li>
<li><code ng:non-bindable="">$scope – {object} – </code>
<p>a scope we can broadcast events from</p></li>
<li><code ng:non-bindable="">rowEntity – {object} – </code>
<p>gridOptions.data[] array instance to make visible and set focus to</p></li>
<li><code ng:non-bindable="">colDef – {object} – </code>
<p>to make visible and set focus to</p></li>
</ul>
</div>
</li>
<li><h3 id="scrollToIfNecessary">scrollToIfNecessary(grid, $scope, gridRow, gridCol)</h3>
<div class="scrolltoifnecessary"><p>Scrolls the grid to make a certain row and column combo visible,
in the case that it is not completely visible on the screen already.</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">grid – {Grid} – </code>
<p>the grid you'd like to act upon, usually available
from gridApi.grid</p></li>
<li><code ng:non-bindable="">$scope – {object} – </code>
<p>a scope we can broadcast events from</p></li>
<li><code ng:non-bindable="">gridRow – {GridRow} – </code>
<p>row to make visible</p></li>
<li><code ng:non-bindable="">gridCol – {GridCol} – </code>
<p>column to make visible</p></li>
</ul>
</div>
</li>
<li><h3 id="scrollToInternal">scrollToInternal(grid, $scope, gridRow, gridCol)</h3>
<div class="scrolltointernal"><p>Like scrollTo, but takes gridRow and gridCol.
In calculating the scroll height we have to deal with wanting
0% for the first row, and 100% for the last row.  Normal maths
for a 10 row list would return 1/10 = 10% for the first row, so
we need to tweak the numbers to add an extra 10% somewhere.  The
formula if we're trying to get to row 0 in a 10 row list (assuming our
index is zero based, so the last row is row 9) is:
<pre class="prettyprint linenums">
  0 + 0 / 10 = 0%
</pre>

<p>To get to row 9 (i.e. the last row) in the same list, we want to
go to:
<pre class="prettyprint linenums">
 ( 9 + 1 ) / 10 = 100%
</pre>
So we need to apportion one whole row within the overall grid scroll,
the formula is:
<pre class="prettyprint linenums">
  ( index + ( index / (total rows - 1) ) / total rows
</pre><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">grid – {Grid} – </code>
<p>the grid you'd like to act upon, usually available
from gridApi.grid</p></li>
<li><code ng:non-bindable="">$scope – {object} – </code>
<p>a scope we can broadcast events from</p></li>
<li><code ng:non-bindable="">gridRow – {GridRow} – </code>
<p>row to make visible</p></li>
<li><code ng:non-bindable="">gridCol – {GridCol} – </code>
<p>column to make visible</p></li>
</ul>
</div>
</li>
</ul>
</div>
</div>
