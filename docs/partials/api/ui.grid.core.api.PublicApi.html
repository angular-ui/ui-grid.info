<h1><code ng:non-bindable="">PublicApi</code>
<span class="hint">(api in module <code ng:non-bindable="">ui.grid.core</code>
)</span>
</h1>
<div><h2 id="Description">Description</h2>
<div class="description"><p>Public Api for the core grid features</p></div>
<div class="member method"><h2 id="Methods">Methods</h2>
<ul class="methods"><li><h3 id="addRowHeaderColumn">addRowHeaderColumn(column)</h3>
<div class="addrowheadercolumn"><p>adds a row header column to the grid</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">column – {object} – </code>
<p>def</p></li>
</ul>
</div>
</li>
<li><h3 id="addToGridMenu">addToGridMenu(grid, items)</h3>
<div class="addtogridmenu"><p>add items to the grid menu.  Used by features
to add their menu items if they are enabled, can also be used by
end users to add menu items.  This method has the advantage of allowing
remove again, which can simplify management of which items are included
in the menu when.  (Noting that in most cases the shown and active functions
provide a better way to handle visibility of menu items)</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">grid – {Grid} – </code>
<p>the grid on which we are acting</p></li>
<li><code ng:non-bindable="">items – {array} – </code>
<p>menu items in the format as described in the tutorial, with 
the added note that if you want to use remove you must also specify an <code>id</code> field,
which is provided when you want to remove an item.  The id should be unique.</p></li>
</ul>
</div>
</li>
<li><h3 id="clearAllFilters">clearAllFilters()</h3>
<div class="clearallfilters"><p>Clears all filters and optionally refreshes the visible rows.</p><h4 id="Returns">Returns</h4>
<div class="returns"><code ng:non-bindable="">{promise}</code>
– <p>If <code>refreshRows</code> is true, returns a promise of the rows refreshing.</p></div>
</div>
</li>
<li><h3 id="clearRowInvisible">clearRowInvisible(rowEntity)</h3>
<div class="clearrowinvisible"><p>Clears any override on visibility for the row so that it returns to 
using normal filtering and other visibility calculations. <br />
If the row is currently invisible then sets it to visible and calls
both grid refresh and emits the rowsVisibleChanged event
TODO: if a filter is active then we can't just set it to visible?</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">rowEntity – {object} – </code>
<p>gridOptions.data[] array instance</p></li>
</ul>
</div>
</li>
<li><h3 id="columnVisibilityChanged">columnVisibilityChanged(column)</h3>
<div class="columnvisibilitychanged"><p>The visibility of a column has changed,
the column itself is passed out as a parameter of the event.</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">column – {GridCol} – </code>
<p>the column that changed</p></li>
</ul>
<h4 id="Example">Example</h4>
<div class="example"><pre class="prettyprint linenums">
gridApi.core.on.columnVisibilityChanged( $scope, function (column) {
  // do something
} );
</pre></div>
</div>
</li>
<li><h3 id="getVisibleRows">getVisibleRows(grid)</h3>
<div class="getvisiblerows"><p>Returns all visible rows</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">grid – {Grid} – </code>
<p>the grid you want to get visible rows from</p></li>
</ul>
<h4 id="Returns">Returns</h4>
<div class="returns"><code ng:non-bindable="">{array}</code>
– <p>an array of gridRow</p></div>
</div>
</li>
<li><h3 id="handleWindowResize">handleWindowResize()</h3>
<div class="handlewindowresize"><p>Trigger a grid resize, normally this would be picked
up by a watch on window size, but in some circumstances it is necessary
to call this manually</p><h4 id="Returns">Returns</h4>
<div class="returns"><code ng:non-bindable="">{promise}</code>
– <p>promise that is resolved when render completes?</p></div>
</div>
</li>
<li><h3 id="notifyDataChange">notifyDataChange(type)</h3>
<div class="notifydatachange"><p>Notify the grid that a data or config change has occurred,
where that change isn't something the grid was otherwise noticing.  This
might be particularly relevant where you've changed values within the data
and you'd like cell classes to be re-evaluated, or changed config within
the columnDef and you'd like headerCellClasses to be re-evaluated.</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">type – {string} – </code>
<p>one of the
uiGridConstants.dataChange values (ALL, ROW, EDIT, COLUMN), which tells
us which refreshes to fire.</p></li>
</ul>
</div>
</li>
<li><h3 id="queueGridRefresh">queueGridRefresh()</h3>
<div class="queuegridrefresh"><p>Request a refresh of the rendered grid on screen, if multiple
calls to queueGridRefresh are made within a digest cycle only one will execute.
The refresh method re-runs both the columnProcessors and the
rowProcessors, as well as calling refreshCanvas to update all
the grid sizing.  In general you should prefer to use queueGridRefresh
instead, which is basically a debounced version of refresh.</p></div>
</li>
<li><h3 id="queueRefresh">queueRefresh()</h3>
<div class="queuerefresh"><p>Requests execution of refreshCanvas, if multiple requests are made
during a digest cycle only one will run.  RefreshCanvas updates the grid sizing.</p><h4 id="Returns">Returns</h4>
<div class="returns"><code ng:non-bindable="">{promise}</code>
– <p>promise that is resolved when render completes?</p></div>
</div>
</li>
<li><h3 id="refresh">refresh()</h3>
<div class="refresh"><p>Refresh the rendered grid on screen.
The refresh method re-runs both the columnProcessors and the
rowProcessors, as well as calling refreshCanvas to update all
the grid sizing.  In general you should prefer to use queueGridRefresh
instead, which is basically a debounced version of refresh.</p>

<p>If you only want to resize the grid, not regenerate all the rows
and columns, you should consider directly calling refreshCanvas instead.</p></div>
</li>
<li><h3 id="refreshRows">refreshRows()</h3>
<div class="refreshrows"><p>Runs only the rowProcessors, columns remain as they were.
It then calls redrawInPlace and refreshCanvas, which adjust the grid sizing.</p><h4 id="Returns">Returns</h4>
<div class="returns"><code ng:non-bindable="">{promise}</code>
– <p>promise that is resolved when render completes?</p></div>
</div>
</li>
<li><h3 id="registerColumnsProcessor">registerColumnsProcessor(processorFunction, priority)</h3>
<div class="registercolumnsprocessor"><p>Register a "columns processor" function. When the columns are updated,
the grid calls each registered "columns processor", which has a chance
to alter the set of columns as long as the count is not
modified.</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">processorFunction – {function(renderedColumnsToProcess, rows )} – </code>
<p>columns processor function, which
is run in the context of the grid (i.e. this for the function will be the grid), and must
return the updated columns list, which is passed to the next processor in the chain</p></li>
<li><code ng:non-bindable="">priority – {number} – </code>
<p>the priority of this processor.  In general we try to do them in 100s to leave room
for other people to inject columns processors at intermediate priorities.  Lower priority columnsProcessors run earlier.</p>

<p>At present allRowsVisible is running at 50, filter is running at 100, sort is at 200, grouping at 400, selectable rows at 500, pagination at 900 (pagination will generally want to be last)</p></li>
</ul>
</div>
</li>
<li><h3 id="registerRowsProcessor">registerRowsProcessor(processorFunction, priority)</h3>
<div class="registerrowsprocessor"><p>Register a "rows processor" function. When the rows are updated,
the grid calls each registered "rows processor", which has a chance
to alter the set of rows (sorting, etc) as long as the count is not
modified.</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">processorFunction – {function(renderedRowsToProcess, columns )} – </code>
<p>rows processor function, which
is run in the context of the grid (i.e. this for the function will be the grid), and must
return the updated rows list, which is passed to the next processor in the chain</p></li>
<li><code ng:non-bindable="">priority – {number} – </code>
<p>the priority of this processor.  In general we try to do them in 100s to leave room
for other people to inject rows processors at intermediate priorities.  Lower priority rowsProcessors run earlier.</p>

<p>At present allRowsVisible is running at 50, sort manipulations running at 60-65, filter is running at 100, 
sort is at 200, grouping and treeview at 400-410, selectable rows at 500, pagination at 900 (pagination will generally want to be last)</p></li>
</ul>
</div>
</li>
<li><h3 id="removeFromGridMenu">removeFromGridMenu(grid, id)</h3>
<div class="removefromgridmenu"><p>Remove an item from the grid menu based on a provided id. Assumes
that the id is unique, removes only the last instance of that id. Does nothing if
the specified id is not found</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">grid – {Grid} – </code>
<p>the grid on which we are acting</p></li>
<li><code ng:non-bindable="">id – {string} – </code>
<p>the id we'd like to remove from the menu</p></li>
</ul>
</div>
</li>
<li><h3 id="removeFromGridMenu">removeFromGridMenu(grid, id)</h3>
<div class="removefromgridmenu"><p>Remove an item from the grid menu based on a provided id.  Assumes
that the id is unique, removes only the last instance of that id.  Does nothing if
the specified id is not found.  If there is no gridMenuScope or registeredMenuItems
then do nothing silently - the desired result is those menu items not be present and they
aren't.</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">grid – {Grid} – </code>
<p>the grid on which we are acting</p></li>
<li><code ng:non-bindable="">id – {string} – </code>
<p>the id we'd like to remove from the menu</p></li>
</ul>
</div>
</li>
<li><h3 id="renderingComplete">renderingComplete(gridApi)</h3>
<div class="renderingcomplete"><p>Rendering is complete, called at the same
time as <code>onRegisterApi</code>, but provides a way to obtain
that same event within features without stopping end
users from getting at the onRegisterApi method.</p>

<p>Included in gridApi so that it's always there - otherwise
there is still a timing problem with when a feature can
call this. </p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">gridApi – {GridApi} – </code>
<p>the grid api, as normally 
returned in the onRegisterApi method</p></li>
</ul>
<h4 id="Example">Example</h4>
<div class="example"><pre class="prettyprint linenums">
gridApi.core.on.renderingComplete( grid );
</pre></div>
</div>
</li>
<li><h3 id="scrollTo">scrollTo(rowEntity, colDef)</h3>
<div class="scrollto"><p>Scroll the grid such that the specified
row and column is in view</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">rowEntity – {object} – </code>
<p>gridOptions.data[] array instance to make visible</p></li>
<li><code ng:non-bindable="">colDef – {object} – </code>
<p>to make visible</p></li>
</ul>
<h4 id="Returns">Returns</h4>
<div class="returns"><code ng:non-bindable="">{promise}</code>
– <p>a promise that is resolved after any scrolling is finished</p></div>
</div>
</li>
<li><h3 id="scrollToIfNecessary">scrollToIfNecessary(gridRow, gridCol)</h3>
<div class="scrolltoifnecessary"><p>Scrolls the grid to make a certain row and column combo visible,
in the case that it is not completely visible on the screen already.</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">gridRow – {GridRow} – </code>
<p>row to make visible</p></li>
<li><code ng:non-bindable="">gridCol – {GridCol} – </code>
<p>column to make visible</p></li>
</ul>
<h4 id="Returns">Returns</h4>
<div class="returns"><code ng:non-bindable="">{promise}</code>
– <p>a promise that is resolved when scrolling is complete</p></div>
</div>
</li>
<li><h3 id="setRowInvisible">setRowInvisible(rowEntity)</h3>
<div class="setrowinvisible"><p>Sets an override on the row to make it always invisible,
which will override any filtering or other visibility calculations. <br />
If the row is currently visible then sets it to invisible and calls
both grid refresh and emits the rowsVisibleChanged event</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">rowEntity – {object} – </code>
<p>gridOptions.data[] array instance</p></li>
</ul>
</div>
</li>
<li><h3 id="sortChanged">sortChanged(grid, sortColumns)</h3>
<div class="sortchanged"><p>The sort criteria on one or more columns has
changed.  Provides as parameters the grid and the output of
getColumnSorting, which is an array of gridColumns
that have sorting on them, sorted in priority order.</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">grid – {Grid} – </code>
<p>the grid</p></li>
<li><code ng:non-bindable="">sortColumns – {array} – </code>
<p>an array of columns with
sorts on them, in priority order</p></li>
</ul>
<h4 id="Example">Example</h4>
<div class="example"><pre class="prettyprint linenums">
gridApi.core.on.sortChanged( grid, sortColumns );
</pre></div>
</div>
</li>
<li><h3 id="sortHandleNulls">sortHandleNulls(a, b)</h3>
<div class="sorthandlenulls"><p>A null handling method that can be used when building custom sort
functions</p><h4 id="Parameters">Parameters</h4>
<ul class="parameters"><li><code ng:non-bindable="">a – {object} – </code>
<p>sort value a</p></li>
<li><code ng:non-bindable="">b – {object} – </code>
<p>sort value b</p></li>
</ul>
<h4 id="Returns">Returns</h4>
<div class="returns"><code ng:non-bindable="">{number}</code>
– <p>null if there were no nulls/undefineds, otherwise returns
a sort value that should be passed back from the sort function</p></div>
<h4 id="Example">Example</h4>
<div class="example"><pre class="prettyprint linenums">
mySortFn = function(a, b) {
var nulls = $scope.gridApi.core.sortHandleNulls(a, b);
if ( nulls !== null ){
  return nulls;
} else {
  // your code for sorting here
};
</pre></div>
</div>
</li>
</ul>
</div>
<div class="member event"><h2 id="Events">Events</h2>
<ul class="events"><li><h3 id="canvasHeightChanged">canvasHeightChanged</h3>
<div class="canvasheightchanged"><p>is raised when the canvas height has changed
<br/>
arguments: oldHeight, newHeight</p><div class="inline"></div>
<div class="inline"></div>
</div>
</li>
<li><h3 id="filterChanged">filterChanged</h3>
<div class="filterchanged"><p>is raised after the filter is changed.  The nature
of the watch expression doesn't allow notification of what changed,
so the receiver of this event will need to re-extract the filter 
conditions from the columns.</p><div class="inline"></div>
<div class="inline"></div>
</div>
</li>
<li><h3 id="rowsRendered">rowsRendered</h3>
<div class="rowsrendered"><p>is raised after the cache of visible rows is changed.</p><div class="inline"></div>
<div class="inline"></div>
</div>
</li>
<li><h3 id="rowsVisibleChanged">rowsVisibleChanged</h3>
<div class="rowsvisiblechanged"><p>is raised after the rows that are visible
change.  The filtering is zero-based, so it isn't possible
to say which rows changed (unlike in the selection feature).
We can plausibly know which row was changed when setRowInvisible
is called, but in that situation the user already knows which row
they changed.  When a filter runs we don't know what changed,
and that is the one that would have been useful.</p><div class="inline"></div>
<div class="inline"></div>
</div>
</li>
<li><h3 id="scrollBegin">scrollBegin</h3>
<div class="scrollbegin"><p>is raised when scroll begins.  Is throttled, so won't be raised too frequently</p><div class="inline"></div>
<div class="inline"></div>
</div>
</li>
<li><h3 id="scrollEnd">scrollEnd</h3>
<div class="scrollend"><p>is raised when scroll has finished.  Is throttled, so won't be raised too frequently</p><div class="inline"></div>
<div class="inline"></div>
</div>
</li>
</ul>
</div>
</div>
